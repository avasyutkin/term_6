from textwrap import wrap

alphabet = ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', '.', ',', '-', '!', '?', ':', ';', '—', '/', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
K = [{'0': 'c', '1': '4', '2': '6', '3': '2', '4': 'a', '5': '5', '6': 'b', '7': '9', '8': 'e', '9': '8', 'a': 'd', 'b': '7', 'c': '0', 'd': '3', 'e': 'f', 'f': '1'},
            {'0': '6', '1': '8', '2': '2', '3': '3', '4': '9', '5': 'a', '6': '5', '7': 'c', '8': '1', '9': 'e', 'a': '4', 'b': '7', 'c': 'b', 'd': 'd', 'e': '0', 'f': 'f'},
            {'0': 'b', '1': '3', '2': '5', '3': '8', '4': '2', '5': 'f', '6': 'a', '7': 'd', '8': 'e', '9': '1', 'a': '7', 'b': '4', 'c': 'c', 'd': '9', 'e': '6', 'f': '0'},
            {'0': 'c', '1': '8', '2': '2', '3': '1', '4': 'd', '5': '4', '6': 'f', '7': '6', '8': '7', '9': '0', 'a': 'a', 'b': '5', 'c': '3', 'd': 'e', 'e': '9', 'f': 'b'},
            {'0': '7', '1': 'f', '2': '5', '3': 'a', '4': '8', '5': '1', '6': '6', '7': 'd', '8': '0', '9': '9', 'a': '3', 'b': 'e', 'c': 'b', 'd': '4', 'e': '2', 'f': 'c'},
            {'0': '5', '1': 'd', '2': 'f', '3': '6', '4': '9', '5': '2', '6': 'c', '7': 'a', '8': 'b', '9': '7', 'a': '8', 'b': '1', 'c': '4', 'd': '3', 'e': 'e', 'f': '0'},
            {'0': '8', '1': 'e', '2': '2', '3': '5', '4': '6', '5': '9', '6': '1', '7': 'c', '8': 'f', '9': '4', 'a': 'b', 'b': '0', 'c': 'd', 'd': 'a', 'e': '3', 'f': '7'},
            {'0': '1', '1': '7', '2': 'e', '3': 'd', '4': '0', '5': '5', '6': '8', '7': '3', '8': '4', '9': 'f', 'a': 'a', 'b': '6', 'c': '9', 'd': 'c', 'e': 'b', 'f': '2'}]

def simple_swap_mode_gamma_generation(X, N1, N2):
    for count_X in range(4):
        if count_X == 3:  # в последних восьми циклах порядок считывания заполнений ключа обратный
            X = X[::-1]

        for i in range(len(X)):
            if int(N1, 2) + int(X[i], 2) > 2 ** 32:  # заполнение накопителя N1 суммируется по модулю 2^32 с заполнением накопителя X
                CM1 = '0' * (32 - len(bin(int(N1, 2) + int(X[i], 2) - 2 ** 32)[2:])) + bin(int(N1, 2) + int(X[i], 2) - 2 ** 32)[2:]
            else:  # если число больше, чем 2^32, то вычитаем
                CM1 = '0' * (32 - len(bin(int(N1, 2) + int(X[i], 2))[2:])) + bin(int(N1, 2) + int(X[i], 2))[2:]

            CM1_ = wrap(CM1, 4)
            CM1 = ''
            for j in range(len(CM1_)):  # осуществляется подстановка в узлах замены по 4 бита на каждый узел
                CM1 += '0' * (4 - len(bin(int(K[j][hex(int(CM1_[j], 2))[2:]], 16))[2:])) + bin(int(K[j][hex(int(CM1_[j], 2))[2:]], 16))[2:]

            CM1 = wrap(CM1, 1)
            CM1 = CM1[11:] + CM1[:11]  # циклический сдвиг на одиннадцать шагов в сторону старших разрядов

            CM2 = ''
            for j in range(len(CM1)):  # результат сдвига суммируется поразрядно по модулю 2 с 32-разрядным заполнением накопителя N2
                CM2 += str((int(CM1[j], 2) + int(N2[j], 2)) % 2)

            N2 = N1  # содержимое N1 записывается в N2
            N1 = CM2  # полученный в СМ2 результат записывается в N1

    return N1, N2

def encryption_decryption(message, K_S):
    message_arr = []
    for i in message:  # переводим в двоичный вид
        message_arr.append('0' * (7 - len(bin(alphabet.index(i))[2:])) + bin(alphabet.index(i))[2:])

    Tо = wrap(''.join(message_arr), 64)  # разбиваем исходное сообщение на блоки по 64 бит

    N1 = K_S[1][0: 32][::-1]  # первые 32 бита синхропосылки записываются в N1 (начинаем с первого разряда)
    N2 = K_S[1][32: 64][::-1]  # последние 32 бита - в N2 (начинаем с первого разряда)

    X = wrap(K_S[0], 32)  # заполняем ключ, разделяя его на блоки по 32 бита
    for i in range(len(X)):
        X[i] = X[i][::-1]  # начинаем с первого разряда

    N1_2 = simple_swap_mode_gamma_generation(X, N1, N2)  # генерируем гамму
    N1 = N1_2[0]
    N2 = N1_2[1]

    N3 = N1[::-1]  # начинаем с первого разряда
    N4 = N2[::-1]  # начинаем с первого разряда

    Tш = ''

    for i in range(len(Tо)):
        if int(N4, 2) + int(N6, 2) > 2 ** 32 - 1:  # 3.1.4
            N4 = '0' * (32 - len(bin(int(N4, 2) + int(N6, 2) - 2 ** 32 + 1)[2:])) + bin(int(N4, 2) + int(N6, 2) - 2 ** 32 + 1)[2:]
        else:
            N4 = '0' * (32 - len(bin(int(N4, 2) + int(N6, 2))[2:])) + bin(int(N4, 2) + int(N6, 2))[2:]

        if int(N3, 2) + int(N5, 2) > 2 ** 32:
            N3 = '0' * (32 - len(bin(int(N3, 2) + int(N5, 2) - 2 ** 32)[2:])) + bin(int(N3, 2) + int(N5, 2) - 2 ** 32)[2:]
        else:
            N3 = '0' * (32 - len(bin(int(N3, 2) + int(N5, 2))[2:])) + bin(int(N3, 2) + int(N5, 2))[2:]

        N1 = N3
        N2 = N4

        N1_2 = simple_swap_mode_gamma_generation(X, N1, N2)
        N1 = N1_2[0][::-1]
        N2 = N1_2[1][::-1]

        N1_2 = N1 + N2


        for j in range(len(Tо[i])):
            Tш += str((int(Tо[i][j], 2) + int(N1_2[j], 2)) % 2)

    Tш_ = wrap(Tш, 7)
    Tш = ''

    for i in Tш_:
        Tш += alphabet[int(i, 2)]
    return Tш


Tо = input("Введите сообщение: ")
K_S = input('Введите ключ (256 бит без пробелов) и синхропосылку (64 бит без пробелов) через пробел: ').split()
K_S = ['1011010100101010101100010101111000101001011001101001010110010010101010010100010110101010101010100101001010101010101011110101010010001010101011101010010101010010100010101010101001010101001010101010100101010101010101010100110000000000010100101011110101010010','0010101101010101111010000101001010110101010101001010101001001010']
N5 = '00000001000000010000000100000001'
N6 = '00000001000000010000000100000100'

Tш = encryption_decryption(Tо, K_S)
print('Зашифрованное соообщение: ', Tш)
Tо = encryption_decryption(Tш, K_S)
print('Расшифрованное сообщение: ', Tо)
